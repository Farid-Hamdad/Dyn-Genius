exemple simulant le Module de r√™ve d‚Äôextraction de liens inattendus
conclusion du test en bas de page.

12 concepts en conflit cyclique et introuvable 
But : v√©rifier que DynG ne diverge pas m√™me face
√† un probl√®me insoluble (objectifs contradictoires et boucles causales impossibles).


import numpy as np
import matplotlib.pyplot as plt

# Classe pour DynG avec r√™ve et exploration des id√©es √©mergentes
class DreamerModule:
    def __init__(self, H, valence, noise_level=0.1, steps=7):
        self.H = H  # Matrice Hebbienne
        self.valence = valence  # Valence des concepts
        self.noise_level = noise_level  # Niveau de bruit pour la propagation
        self.steps = steps  # Nombre d'√©tapes dans le r√™ve

    def dream(self, A_init=None, seed=None):
        """Proc√®de √† un r√™ve en utilisant la matrice H"""
        if A_init is None:
            A_init = np.zeros(len(self.H))
        
        if seed:
            np.random.seed(seed)

        # Propagation avec bruit
        A = A_init
        dream_sequence = [A.copy()]

        for _ in range(self.steps):
            A = np.tanh(np.dot(self.H, A) + np.random.normal(0, self.noise_level, len(A)))  # Propagation avec bruit
            dream_sequence.append(A.copy())
        
        return np.array(dream_sequence)

    def extract_ideas(self, dream_sequence, threshold=0.6):
        """Extrait les id√©es √©mergentes en fonction du seuil"""
        activated_ideas = []
        for step, A in enumerate(dream_sequence):
            activated_concepts = np.where(A >= threshold)[0]
            if activated_concepts.size > 0:
                activated_ideas.append({
                    'step': step,
                    'activated_concepts': activated_concepts,
                    'values': A[activated_concepts]
                })
        return activated_ideas

# Initialisation des concepts conflictuels
unsolvable_concepts = [
    {"name": "S√©curit√©",        "G":  0.95, "pi": 0.9, "valence":  1,
     "logic": {"cause": [1, 2], "contradiction": [3, 4]}},
    {"name": "Innovation",      "G":  0.90, "pi": 0.8, "valence":  1,
     "logic": {"cause": [5],    "contradiction": [0]}},
    {"name": "Rapidit√©",        "G":  0.85, "pi": 0.8, "valence":  1,
     "logic": {"cause": [6],    "contradiction": [0, 3]}},
    {"name": "Conformit√©",      "G":  0.90, "pi": 0.8, "valence":  1,
     "logic": {"contradiction": [1, 2, 5, 6]}},
    {"name": "Co√ªt_Faible",     "G":  0.95, "pi": 0.9, "valence":  1,
     "logic": {"contradiction": [1, 2]}},
    {"name": "R&D_Lourde",      "G":  0.80, "pi": 0.7, "valence": -1,
     "logic": {"cause": [4],    "contradiction": [4]}},   # boucle impossible
    {"name": "Agilit√©",         "G":  0.80, "pi": 0.7, "valence": -1,
     "logic": {"contradiction": [3]}},
    {"name": "Charge_Cognitive","G": -0.90, "pi": 0.8, "valence": -1,
     "logic": {"cause": [8, 9]}},
    {"name": "Fatigue",         "G": -0.85, "pi": 0.7, "valence": -1,
     "logic": {"cause": [10],   "contradiction": [0, 1, 2]}},
    {"name": "Stress",          "G": -0.80, "pi": 0.7, "valence": -1,
     "logic": {"cause": [11],   "contradiction": [2]}},
    {"name": "Erreur_Humaine",  "G": -0.75, "pi": 0.6, "valence": -1,
     "logic": {"cause": [0],    "contradiction": [0]}},   # boucle paradoxale
    {"name": "Pression_Temps",  "G": -0.80, "pi": 0.6, "valence": -1,
     "logic": {"cause": [2, 9], "contradiction": [4]}}
]

# Conversion des concepts en matrices G, pi et valence
G = np.array([concept["G"] for concept in unsolvable_concepts])
pi = np.array([concept["pi"] for concept in unsolvable_concepts])
valence = np.array([concept["valence"] for concept in unsolvable_concepts])

# Matrice H de causalit√©
H = np.random.rand(len(unsolvable_concepts), len(unsolvable_concepts)) * 0.5  # H initialis√©e al√©atoirement
np.fill_diagonal(H, 0)  # Pas de boucles sur soi-m√™me

# Cr√©ation du module de r√™ve et simulation
dreamer = DreamerModule(H, valence, noise_level=0.2, steps=15)
dream_sequence = dreamer.dream(A_init=np.zeros(len(unsolvable_concepts)), seed=42)
ideas = dreamer.extract_ideas(dream_sequence, threshold=0.6)

# Affichage des id√©es √©mergentes √† chaque √©tape
for idea in ideas:
    print(f"√âtape {idea['step']}: Concepts activ√©s = {', '.join([unsolvable_concepts[i]['name'] for i in idea['activated_concepts']])}, Valeurs = {idea['values']}")

# Visualisation des r√©sultats sous forme graphique
def plot_dream_sequence(dream_sequence, concepts_names):
    plt.figure(figsize=(12, 6))
    for step, A in enumerate(dream_sequence):
        plt.plot(range(len(concepts_names)), A, label=f"√âtape {step}")
    plt.xticks(range(len(concepts_names)), concepts_names, rotation=90)
    plt.xlabel("Concepts")
    plt.ylabel("Activation")
    plt.title("√âvolution des Activations des Concepts dans le R√™ve")
    plt.legend()
    plt.tight_layout()
    plt.show()

# Affichage graphique de l'√©volution des activations
plot_dream_sequence(dream_sequence, [concept["name"] for concept in unsolvable_concepts])

**************************************************************************************************************
L'interpr√©tation des r√©sultats peut effectivement √™tre complexe, mais voici quelques points cl√©s √† consid√©rer 
lors de l‚Äôanalyse des activations et des id√©es √©mergentes :

1. √âvolution des activations des concepts :
Les activations des concepts montrent l'importance relative de chaque concept au cours du r√™ve. Si un concept
a une activation √©lev√©e, cela signifie qu‚Äôil a une forte 
influence dans l‚Äôactivation g√©n√©rale du syst√®me.
Si plusieurs concepts sont activ√©s √† chaque √©tape, cela peut signifier que DynG explore diff√©rentes dimensions
du probl√®me, fusionnant des id√©es contradictoires pour trouver des solutions ou des associations in√©dites.

2. Id√©es √©mergentes :
Lorsqu‚Äôun concept atteint un seuil d‚Äôactivation, il est consid√©r√© comme une id√©e √©mergente. Cela peut √™tre vu
comme un nouveau lien, une nouvelle perspective ou une solution possible qui √©merge en r√©ponse aux interactions 
internes des concepts.
Ces id√©es peuvent refl√©ter des contradictions internes (par exemple, des concepts contradictoires
comme "Innovation" et "Co√ªt_Faible" pourraient se combiner de mani√®re surprenante dans un r√™ve pour sugg√©rer
un compromis, une solution innovante √† faible co√ªt).
Exemple d‚Äôinterpr√©tation d'une √©tape donn√©e (par exemple √âtape 9 avec activations de Grid_Safety) :
Concept activ√© : Grid_Safety avec une activation de 0.55. Cela signifie que, parmi tous les concepts 
dans le syst√®me, la s√©curit√© du r√©seau est devenue l‚Äôun des principaux moteurs de la pens√©e du syst√®me √† cette √©tape.
Contexte : Si l'on consid√®re le contexte de concepts conflictuels comme "Co√ªt_Faible", "Innovation", "Stress", etc.
Grid_Safety pourrait √™tre activ√© pour essayer de r√©soudre une contradiction li√©e √† des compromis sur la s√©curit√©
du r√©seau face √† l‚Äôinnovation et aux co√ªts.
Cela pourrait sugg√©rer qu'√† ce moment-l√†, le syst√®me a trouv√© une priorit√© pour la s√©curit√©, ce qui est peut-√™tre 
une r√©ponse logique aux tensions internes caus√©es par des objectifs contradictoires.

3. Graphique des activations :
Le graphique de l‚Äô√©volution des activations √† travers les √©tapes montre comment les concepts √©voluent. En observant 
les courbes, tu peux remarquer certains concepts qui deviennent plus influents (activations croissantes) ou qui 
perdent en importance (activations d√©croissantes).
Les sauts soudains dans les activations peuvent signaler que le syst√®me a trouv√© une nouvelle relation ou une id√©e √©mergente.

4. Cycles et contradictions :
Si tu vois des concepts comme "R&D_Lourde" ou "Erreur_Humaine" qui sont li√©s √† des boucles logiques ou paradoxales,
leur activation pourrait montrer que le syst√®me lutte pour r√©soudre des probl√®mes insolubles. Cela peut √™tre
un point d'√©mergence d'id√©es o√π DynG explore de mani√®re non conventionnelle comment g√©rer les contradictions.
Les contradictions internes dans les relations logiques de ces concepts, comme entre Innovation et Co√ªt_Faible, 
peuvent cr√©er des solutions hybrides ou une priorit√© nouvelle qui ne serait pas apparue dans une analyse plus traditionnelle.

5. Id√©es de compromis :
"Innovation" contre "Co√ªt_Faible" ou "S√©curit√©" : Le syst√®me pourrait √©merger avec une id√©e comme "innovation
√† faible co√ªt", ou "innovations qui ne compromettent pas la s√©curit√©", m√™me si ces concepts sont contradictoires.
Ce type de solution hybride ou compromis pourrait √™tre une id√©e √©mergente int√©ressante.

En r√©sum√© :
Les id√©es √©mergentes sont g√©n√©r√©es √† travers la propagation des activations, qui sont influenc√©es par la matrice 
Hebbienne ùêª
H et la valence des concepts. Si certains concepts ont une activation √©lev√©e, cela signifie qu'ils jouent un r√¥le
central dans la r√©solution du conflit ou de la probl√©matique en question.

Les r√©sultats d‚Äôune simulation de r√™ve comme celle-ci peuvent √™tre interpr√©t√©s comme des explorations internes du 
syst√®me, cherchant √† r√©soudre des contradictions logiques ou √† identifier des comportements √©mergents face √† des
tensions entre des objectifs contradictoires.

L‚Äôobjectif ici est de permettre √† DynG de proposer des id√©es in√©dites ou des solutions cr√©atives qui ne seraient 
pas √©videntes sans ce processus de propagation dynamique et de r√™ve.
